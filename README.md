# SC23
Region-Aware Power Management

module list
Currently Loaded Modules:
  1) craype-x86-rome                         7) craype/2.7.21
  2) libfabric/1.15.2.0                      8) cray-dsmml/0.2.2
  3) craype-network-ofi                      9) cray-mpich/8.1.26.115
  4) perftools-base/23.05.0                 10) cray-libsci/23.05.1.4
  5) xpmem/2.5.2-2.4_3.18__gd0f7936.shasta  11) PrgEnv-cray/8.4.0
  6) cce/16.0.0
  
The computational artifacts provide a workflow to run our implementation of the algorithm alongside the benchmarks and generate performance, power, and energy results. To launch a run, one should run the software program binary with the file location of the application binary as the first argument and the target performance level as the second argument. Additionally, there needs to be a script that our program can call that launches the desired SPEC rate application with the proper application configuration. The provided scripts use numactl to pin each copy of the application to its own physical core, and we can measure average clock frequency by attaching perf record (cpu-cycles, cpu-clock) to one of the copies. This script will also measure the time and energy of the system before and after the application finishes by reading the appropriate system files, detailed below. All applications are compiled using Cray Compiling Environment (CCE) with the highest optimization flag, -fast or -Ofast. Running each SPEC application varies in execution time; the total runtime of all applications is about two hours on our AMD EPYC 9654 (Genoa with 96-core CPUs and 384GB RAM) system. Complete replication of our results will thus take at least twelve hours to run, since we demonstrate three different performance levels at both the socket level and the node level.

The time (in microseconds) and energy (in Joules) at the beginning and end of the run are recorded in a text file for each application individually, which can then be plugged into an Excel sheet to generate plots. Since we measure accumulating values, the difference must be taken to derive time and energy for that specific run, and average power can be calculated by dividing energy by time. No additional conversions or concern about overflow are necessary due to the hardware and environment configuration. Specifically, we use a Cray EX system with Cray OS, which provides access to PM counters that provide this data through system files. The results we present in the paper are all relative to results from a default SPEC rate run (i.e., without our software/algorithm). These default results can be generated by just running the script itself, which as mentioned earlier already incorporates measuring time and energy.
